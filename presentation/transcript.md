# Understanding JWT (JSON Web Token)

Hello and welcome to my simple presentation of JWT (JSON Web Token), that used for securing interactions between users and web aplications.

Here are some basic topics that will be covered during my speech. First, we'll take a look at what JWT is. Next, we will consider its structure and creation rules. Let's see what a header, payload, and signature are. After that, we will look at how the token is verified. In conclusion, I'll suggest links to further explore the topic.

So, take a comfortable seat and I'll start.

- [Understanding JWT (JSON Web Token)](#understanding-jwt-json-web-token)
  - [What is JSON Web Token?](#what-is-json-web-token)
  - [JWT structure & creation](#jwt-structure--creation)
    - [JWT Header (First step of creation)](#jwt-header-first-step-of-creation)
    - [JWT Payload (Second step of creation)](#jwt-payload-second-step-of-creation)
    - [JWT Signature (Third step)](#jwt-signature-third-step)
  - [JWT Verifying](#jwt-verifying)
  - [Conclusion](#conclusion)
  - [What next?](#what-next)
  - [Related materials](#related-materials)

## What is JSON Web Token?

For the beginning, a little bit of terminology.

JSON Web Token (JWT) is an open standard (RFC 7519) that defines a compact and self-contained way for securely transmitting information between parties as a JSON object. This information can be verified and trusted because it is digitally signed. JWTs can be signed using a secret (with the HMAC algorithm) or a public/private key pair using RSA or ECDSA.

In simple words, JWT is just a string in the following format

`header.payload.signature`

For better undestanding of JWT, let's imagine a realworld situation. For example, we want to register on a web-site. In our case, there are will be three participants — user, application server and authentication server. The authentication server will provide to user a token, whitch help to interact with the application.

![JWT Auth interaction schema](/presentation/images/jwt-schema.png)

First of all, user sign-in providing the credentials (for example, username and password, using Facebook, Google, or same service if possible). The authentication server then creates a JWT and sends it to the user. When the user makes API calls to the application, the user passes the JWT along with the API call. It must be included in header of every request.

`Authorization: Bearer <token>`

The application server must be configured to verify inbound JWTs and check if they are generated by the authentication server. So, when a user makes API calls with a JWT attached, the application can use the JWT to verify that the API call comes from an authenticated user.

Let's take a closer look at the process of creating and verifying a JWT token.

## JWT structure & creation

The JWT consists of three parts: header, payload, and signature. Let's go through each of them.

### JWT Header (First step of creation)

The header typically consists of two parts: the type of the token, which is JWT, and the signing algorithm being used, such as HMAC SHA256 or RSA.

For example:

`{ "alg": "HS256", "typ": "JWT" }`

Then, this JSON is Base64Url encoded to form the first part of the JWT.

### JWT Payload (Second step of creation)

The second part of the token is the payload, which contains the claims. Claims are statements about an entity (typically, the user) and additional data. For example, the authentication server creates a JWT with the user information stored inside of it, specifically the user ID.

`{ "userId": "b08f86af-35da-48f2-8fab-cef3904660bd" }`

In this example, we are only putting one claim into the payload. You can put as many claims as you need, but keep in mind that the size of the data will affect the overall size of the JWT. This generally isn’t an issue but having excessively large JWT may negatively affect performance and cause latency.

**Do not put secret information in the payload or header elements of a JWT unless it is encrypted.**

### JWT Signature (Third step)

The signature is used to verify the message wasn't changed along the way, and, in the case of tokens signed with a private key, it can also verify that the sender of the JWT is who it says it is.

Creating signature using the following pseudo code:

`const SECRET_KEY = 'cAtwa1kkEy'`

`const unsignedToken = base64urlEncode(header) + '.' + base64urlEncode(payload)`

`const signature = HMAC-SHA256(unsignedToken, SECRET_KEY)`

The result with our example data may looks like this:

`eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJ1c2VySWQiOiJiMDhmODZhZi0zNWRhLTQ4ZjItOGZhYi1jZWYzOTA0NjYwYmQifQ.-xN_h82PHVTCMA9vdoHrcZxH-x5mb11y1537t3rGzcM`

The base64url algorithm encodes the header and payload created in previous steps. The algorithm concatenates encoded strings through a dot. Then, the resulting string is hashed by the algorithm specified in the header based on secret key.

If you want to play with JWT and put these concepts into practice, you can use [jwt.io Debugger](https://jwt.io/#debugger-io) to decode, verify, and generate JWTs.

## JWT Verifying

Now that we know how to encode a JWT, decoding is pretty easy. We start by splitting the token by the periods, and then decode each section separately:

`base64Header, base64Payload, signature = token.split('.')`

`header = base64Decode(base64Header)`

`payload = base64Decode(base64Payload)`

The slightly more complicated part is when we need to verify the signature. We do this by recreating the signature from the header and payload using our secret, and then check to see if it matches the signature we were given. If it doesn't, then either the token isn't authentic or it has been altered in some way.

`cs = HS256(base64Header + '.' + base64Payload, 'cAtwa1kkEy');`

`if (cs != signature) { throw new Error('FAILED'); }`

Keep in mind that in most cases you should check the header to see which algorithm was used in the signature. I can skip that part here for our purposes.

## Conclusion

We walked through what JWTs are, how to create and how to validate it, how it can be used to establish a trust relationship between a user and an application. But this is just a piece of the puzzle of the big topic of authorizing and securing web applications. We have covered only the basics, but without them it is impossible to move on.

## What next?

The next step to improve the security of the application is the Refresh Token topic. A refresh token is a special kind of token used to obtain a renewed access token. Look for additional links in related materials.

## Related materials

Here I suggest a few useful links for more deep dive into the JWT topic.

- [JWT.IO](https://jwt.io/)
- [jsonwebtoken library for node.js](https://github.com/auth0/node-jsonwebtoken)
- [Understanding JSON Web Tokens (JWT)](https://stackabuse.com/understanding-json-web-tokens-jwt/)
- [What Is JWT and Why Should You Use JWT (video)](https://www.youtube.com/watch?v=7Q17ubqLfaM)
- [Refresh tokens](https://auth0.com/docs/tokens/refresh-tokens)
- [Refresh Tokens: When to Use Them and How They Interact with JWTs](https://developer.okta.com/blog/2019/08/12/build-secure-react-application-redux-jwt)
- [Build a Secure React Application with JWTs](https://developer.okta.com/blog/2019/08/12/build-secure-react-application-redux-jwt)

For additional info check the description under this video.

Thank you for attention!
